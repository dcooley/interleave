---
output: github_document
---

[![R build status](https://github.com/dcooley/interleave/workflows/R-CMD-check/badge.svg)](https://github.com/dcooley/interleave/actions)

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = ">",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# interleave

I'm building this library to be the workhorse for converting matrices (and lists of matrices) into single, interleaved vectors, ready for WebGL applications.



```{r}

( mat1 <- matrix(1:20, ncol = 2, byrow = T) )

interleave:::rcpp_interleave( mat1 )

( mat2 <- matrix(20:1, ncol = 5, byrow = T) )

interleave:::rcpp_interleave( mat1 )

lst <- list( mat1, mat2 )

interleave:::rcpp_interleave( lst )

```


## Ear-cutting / geometries / polygon structures

dunno if this is going to stay here or not. I've deviated away from `mapbox::earcut` slightly by returning coordinates directly, and accepting any dimension (XY(Z(M(...n))), and so I can't make it nicely fit in `decido`



```{r}

x <- c(0, 0, 0.75, 1, 0.5, 0.8, 0.69)
y <- c(0, 1, 1, 0.8, 0.7, 0.6, 0)
mat <- cbind(x, y)
lst <- list( mat )
interleave:::rcpp_earcut_sfg( lst )



```

## Don't run this yet, it will crash your system.

```{r}

# x1 <- c(0, 0, 0.75, 1, 0.5, 0.8, 0.69)
# x2 <- c(0.2, 0.5, 0.5, 0.3, 0.2)
# y1 <- c(0, 1, 1, 0.8, 0.7, 0.6, 0)
# y2 <- c(0.2, 0.2, 0.4, 0.6, 0.4)
# 
# mat1 <- cbind(x1, y1)
# mat2 <- cbind(x2, y2)
# 
# lst <- list( mat1, mat2 )
# 
# interleave:::rcpp_earcut_sfg()

```


```{r}

mat <- matrix(rnorm(5e6), ncol = 5, byrow = T)

microbenchmark::microbenchmark(
  leave = { interleave:::rcpp_interleave( mat ) },
  asvec = { as.vector( t( mat ) ) },
  baset = { 
    mat2 <- t( mat )
    dim( mat2 ) <- NULL
    },
  times = 25
)

```

